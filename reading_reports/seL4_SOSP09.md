# AOS-report 4
## seL4: Formal Verification of an OS Kernel
- **Authors：**  Gerwin Klein, Kevin Elphinstone, Gernot Heiser, June Andronick, David Cock, Philip Derrin, Dhammika Elkaduwe, Kai Engelhardt, Rafal Kolanski, Michael Norrish, Thomas Sewell, Harvey Tuch, Simon Winwood
- **Paper：** https://www.sigops.org/s/conferences/sosp/2009/papers/klein-sosp09.pdf
## Summary of major innovations

完全的形式化验证能够确保系统不会出现逻辑漏洞和内存漏洞，不存在编程和设计上的错误，具有高度安全性和可靠性。这篇论文提出了第一个经过形式化验证并证明其功能正确的完整的通用的操作内核。这篇论文的前提假设是编译器、汇编代码和硬件都是可信的，在此基础上实现了seL4内核从抽象规约层到C语言实现层的形式化验证。这篇论文证明了seL4操作系统在任何情况下都不会崩溃，以及执行不安全的操作，并且可以精确地推断出seL4在所有情况下的行为。这篇论文在对内核的规约层面做分析的同时也对内核的精细行为进行了规约和验证。在本文所描述的功能正确性要比模型检验、静态分析以及采用类型安全编程语言实现的内核要强的多。此外，这篇论文还创立了一套融合了传统操作系统研发技术和形式化方法技术，用来快速实现内核设计与实现的方法学，经过实践证明，利用这套方法学开发出的操作系统不仅在安全性上有着充分的保障，在性能上也不会受到影响。
 
### Contribution
- 它适用于实际使用，拥有与性能最佳的微内核相当的性能
- 其行为在抽象层进行了精确的规约
- 其形式化设计能够用来证明中断等属性的安全性。
- 其实现满足规约
- 其访问控制机制能够得到证实，保证高强度的安全性。

### The seL4 Design
![img](https://camo.githubusercontent.com/fe5bb7167d4369e4baa6d0e8cec78b2c7854d86f/68747470733a2f2f692e696d6775722e636f6d2f73735746545a682e706e67)

这张图的大矩形就是形式化验证所用到的所有模型，双箭头代表着实现或者证明。矩形中间是实现的Haskell 原型，这个原型如果需要得到底层的硬件实现则需要设计和实现相关的算法。为了能够运行原型代码，这篇论文使用了从QEMU中抽取出来的虚拟化平台，这样的话所有仿真操作都能够完整的表现出来操作系统的各种行为。

Haskell 代码虽然是一个可执行的接近于最终实现的代码，但是仍然不是最终的C代码。因此作者采用人工的方式用C语言重新对内核进行了实现。一方面，Haskell 的运行环境包含了大量的难以验证的代码。另一方面，Haskell 的代码依赖于内存回收机制，这种机制使其难以在实际应用环境中使用。

此外，使用C 可以在底层的实现中进行优化。虽然可以直接从Haskell 代码编译成C 代码，但是这样会使得系统的性能受到影响。

### The refinement layers in the verification of seL4
这篇论文使用Isabelle/HOL进行定理证明，使用交互式机器协助定理证明。交换式定理证明主要由人来创建和引导整个定理的证明。这样的话，不会像静态分析和模型检验那样，受限于特定的属性或者有穷的状态空间。
这篇论文采用了一种精炼证明策略，论证最强意义上的功能正确性。本文采用的精炼证明策略能够确保高层抽象和系统底层的一致性，从而确保了 Hoare 逻辑在抽象层的属性在底层依然适用。

![img](https://camo.githubusercontent.com/7ca936a659a687250142a154ce8e686162ef91c4/68747470733a2f2f692e696d6775722e636f6d2f634d38655074352e706e67)

这张图显示的是用于 seL4 验证的规约层次。
抽象规约层是最顶层，这一层对系统的主要的完整行为进行规约，包含足够的细节体现系统的外在特性。然而这一层并没有具体到这些特性都是如何实现的。

第二层是执行规约层，这一层的规约由Haskell 的原型产生。本层包含了所有的数据结构的描述和实现细节。

最底层的是 C代码实现层，要求所使用的 C 代码必须有明确的语义。

## What the problems the paper mentioned?
这篇论文针对的问题是操作系统的可靠性和安全性问题。由于内核的权限极高，可以随意访问硬件，因此操作系统内核的微小错误或者漏洞都会影响整个计算机系统。而完全的形式化验证能够确保系统不会出现逻辑漏洞和内存漏洞，不存在编程和设计上的错误，具有高度安全性和可靠性。为了解决操作系统的可靠性和安全性，作者提出了这篇论文。

## How about the important related works/papers?
- UCLA Secure Unix 
    - UCLA第一次尝试验证操作系统内核，完成了90%的规约和20%的验证。本文借鉴了UCLA的功能正确性的验证思路。
- PSOS 
    - PSOS和UCLA一样，都是在十九世纪七十年代末第一次尝试验证操作系统内核。然而POSO主要关注于内核设计的形式化验证，从来没有完成过大量的实现证明。
- KIT
    -  第一个实际的完整的操作系统内核的形式化证明。然而其目标对象是一个高度理想化的操作系统内核，并不能在实际机器上运行
-  Verisoft
    -  Verisoft 想要验证操作系统的内核和从硬件到应用程序的完整的软件栈。这里面包含了类似于 Pascal 语言的已经验证过的编译器。这项工作证明了形式化验证汇编层代码是可以实现的。该项工作基于VAMP硬件平台。而本文的seL4操作系统是基于ARM6平台，该平台相对被更广泛的使用。

## What are some intriguing aspects of the paper?
我觉得这篇论文有以下几个方面比较有意思：
- 形式化验证的方法是倾向于采用自顶向下的设计方法，操作系统开发倾向于采用自底向上的内核开发方法。这篇论文没有拘于现有的开发模式，结合这两种方法做了一个折中，用面向过程的Haskell 语言实现了一个内核原型。
- 通过seL4 验证的规约层次就可以知道seL4的验证步骤
    - 写出IPC，syscall，调度等所有微内核对象的抽象规范
    - 写出上述对象的在Haskell里的可执行规范，并证明其正确地实现了第一步的抽象规范
    - 第三步是手写C语言，用Haskabelle形式化证明C代码和第二步的Haskell定义语义一致。
    - 作者说对于缓冲区溢出、解引用空指针、指针类型错误、内存泄露、算法溢出以及边界越界等内存错误是不会发生在seL4中的。这些错误基本上都是内存错误，但是作者没有谈论如何证明逻辑漏洞在seL4上也是不存在的，还有JIT漏洞的讨论与分析

## How to test/compare/analyze the results?
- Debug测试
    - seL4在C代码实现层发现了160个bug，在执行规约层发现大约150个bug，在抽象规约层发现大约150个bug
    - 一共发现了460个bug
- IPC性能测试
    - IPC性能是微内核评估最关键的指标，因为所有交互都是用IPC进行

## How can the research be improved?
- 这篇论文仅限C代码的实现，可以扩展成更多语言的实现
- 作者没有在优化方面投入大量的精力，但是已经证明是可以优化的，所以seL4可以进一步优化
- 这篇论文没有验证内核的组件部分以及内核的多核版本，可以对此做进一步的验证

## If you write this paper, then how would you do?
- Sorry，I have no ideal.


